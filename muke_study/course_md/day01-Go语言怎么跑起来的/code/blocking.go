package main

import (
	"encoding/json"
	"fmt"
	"net"
	"sync"
	"time"
)

/*
在线程发生阻塞的时候，会无限制地创建线程么？并不会!!先来看看阻塞有哪几种情况

这些情况不会阻塞调度循环，而是会把 goroutine 挂起所谓的挂起，其实让 g 先进某个数据结构，待 ready 后再继续执行不会占用线程这时候，线程会进入 schedule，继续消费队列，执行其它的 g
*/

type Demo struct {
	Field1 * struct{
		Field3 int `json:"field-3,omitempty" xml:"field_3"`
	}
	Field2 string
	Field3 bool
}

func _(){
	_ = Demo{}
}

type Animal struct {
	//只能在本包中被访问
	name string
}

func NewAnimal() *Animal {
	return &Animal{}
}

func (p *Animal) SetName(name string) {
	p.name = name
}

func (p *Animal) GetName() string {
	return p.name
}

type AutoGenerated struct {
	Age   int    `json:"age"`
	Name  string `json:"name"`
	Child []int  `json:"child"`
}


func main() {
	jsonStr1 := `{"age": 14,"name": "potter", "child":[1,2,3]}`
	a := AutoGenerated{}
	json.Unmarshal([]byte(jsonStr1), &a)
	aa := a.Child
	fmt.Println(aa)
	jsonStr2 := `{"age": 12,"name": "potter", "child":[3,4,5,7,8,9]}`
	json.Unmarshal([]byte(jsonStr2), &a)
	fmt.Println(a)
	fmt.Println(aa)
}

func netReadWrite() {
	var c net.Conn
	var buf = make([]byte, 1024)

	// data not ready , block here
	n, err := c.Read(buf)
	fmt.Println(n, err)

	// send buffer full, write blocked
	var buf2 = []byte("hello")
	n, err = c.Write(buf2)
	fmt.Println(n, err)
}

func readLock() {
	var l sync.RWMutex
	// somebody already grab the lock
	// block here
	l.Lock()
}

func overtime() {
	//一直陷入等待1H
	time.Sleep(time.Hour)
}
func channelSelect() {
	var (
		ch1 = make(chan int)
		ch2 = make(chan int)
	)
	// no case ready ,block  没有default语句 select一直陷入等待
	//fatal error: all goroutines are asleep - deadlock!
	select {
	case <-ch1:
		println("ch1 ready")
	case <-ch2:
		fmt.Println("ch2 ready")
		/*default:
		fmt.Println("全都陷入等待")*/
	}
}

func channelSend() {
	//channel send:
	// 由于是无缓冲通道不能先缓冲值 会导致goroutine死锁
	var ch = make(chan int)
	ch <- 1 //fatal error: all goroutines are asleep - deadlock!
	fmt.Println(<-ch)
}

func channelRecv() {
	//channel send:
	// 由于是无缓冲通道 无值取值导致主goroutine陷入等待 会导致goroutine死锁
	var ch = make(chan int)
	<-ch //fatal error: all goroutines are asleep - deadlock!
}
